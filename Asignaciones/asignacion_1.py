# -*- coding: utf-8 -*-
"""Asignacion_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cY6NwQBucSqhCz9jPAIdAmLyEciCGsX1

# **Asignación 1**
**Estudiante:** Danna Sofía Hernandez Cala
**Código:** 2240666
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
from google.colab import drive
drive.mount('/content/drive')

""""Calcule la distancia euclidea para varios valores de la ventana móvil y determine el mejor de los valores para la ventana"
"""

# Cargar los datos de referencia y de los sensores a calibrar (IoT)

datos_ref = pd.read_excel("/content/drive/MyDrive/Datos_Estaciones_AMB.xlsx", sheet_name="Caldas")

datos_ref["Date&Time"] = pd.to_datetime(datos_ref["Date&Time"], utc=True, errors="coerce")
datos_ref = datos_ref.rename(columns={"PM2.5": "pm25_ref"})
datos_ref["pm25_ref"] = datos_ref["pm25_ref"].replace(['NoData', '---', '<Samp'], np.nan)
datos_ref = datos_ref[["Date&Time", "pm25_ref"]].dropna()
datos_ref["pm25_ref"] = datos_ref["pm25_ref"].astype(float)
datos_ref = datos_ref.sort_values("Date&Time")

datos_iot = pd.read_excel("/content/drive/MyDrive/mediciones_clg_normalsup_pm25.xlsx")
datos_iot["fecha_hora_med"] = pd.to_datetime(datos_iot["fecha_hora_med"], utc=True, errors="coerce")
datos_iot = datos_iot.rename(columns={"valor": "pm25_iot"})
datos_iot = datos_iot[["fecha_hora_med", "pm25_iot"]].dropna()
datos_iot["pm25_iot"] = datos_iot["pm25_iot"].astype(float)
datos_iot = datos_iot.sort_values("fecha_hora_med")

def promedio_en_ventana(tiempos, valores, centro, w):
    mitad = pd.Timedelta(minutes=w/2)
    intervalo = tiempos.between(centro - mitad, centro + mitad)
    vals = valores[intervalo]
    return vals.mean() if not vals.empty else np.nan

def calcular_distancia(datos_ref, datos_iot, w):
    inicio = max(datos_ref["Date&Time"].min(),
                 datos_iot["fecha_hora_med"].min())
    fin = min(datos_ref["Date&Time"].max(), datos_iot["fecha_hora_med"].max())
    paso = pd.Timedelta(minutes=w/2)
    centros = pd.date_range(start=inicio+pd.Timedelta(minutes=w/2),
                            end=fin-pd.Timedelta(minutes=w/2), freq=paso)

    ref_vals, iot_vals = [], []
    for c in centros:
        pr = promedio_en_ventana(datos_ref["Date&Time"],
                                 datos_ref["pm25_ref"], c, w)
        pi = promedio_en_ventana(datos_iot["fecha_hora_med"],
                                 datos_iot["pm25_iot"], c, w)
        if not np.isnan(pr) and not np.isnan(pi):
            ref_vals.append(pr)
            iot_vals.append(pi)

    if len(ref_vals) == 0:
        return np.nan, []

    ref_vals, iot_vals = np.array(ref_vals), np.array(iot_vals)
    promedio = np.sqrt(np.sum((ref_vals - iot_vals)**2))
    return promedio, list(zip(ref_vals, iot_vals))

ventanas = [15, 30, 60, 120, 180]
resultados = {}
pares_por_ventana = {}

for w in ventanas:
    promedio, pares = calcular_distancia(datos_ref, datos_iot, w)
    resultados[w] = promedio
    pares_por_ventana[w] = pares
    print(f"Ventana: {w} minutos - promedio: {promedio}")

mejor_w = min(resultados, key=resultados.get)
pares_optimos = np.array(pares_por_ventana[mejor_w])

""""Determine el alcance de validez del modelo lineal"
"""

y_iot = pares_optimos[:,1]
y_ref = pares_optimos[:,0]
alpha = np.sum(y_iot*y_ref)/np.sum(y_iot**2)
y_pred = alpha * y_iot #f(xi)=af^(x^i)
promedio_final = np.sqrt(np.mean((y_ref - y_pred)**2)) #distancia minima

tol_abs = 5.0  # µg/m³
tol_rel = 0.1 * np.mean(y_ref)  # 10% del promedio ref

errors = np.abs(y_ref - y_pred)
frac_within_abs = np.mean(errors <= tol_abs)
frac_within_rel = np.mean(errors <= tol_rel)

print("Resultados:")
print("Mejor ancho de ventana (min):", mejor_w)
print("promedio por ventana:", resultados)
print("α =", alpha)
print("promedio final (modelo calibrado):", promedio_final)
print(f"Fracción dentro tol_abs={tol_abs}: {frac_within_abs:.3f}")
print(f"Fracción dentro tol_rel={tol_rel:.3f}: {frac_within_rel:.3f}")

plt.figure(figsize=(5,5))
plt.scatter(y_iot, y_ref, label="Datos emparejados", alpha=0.6)
plt.plot(y_iot, y_pred, 'r.', label="Modelo calibrado")
plt.plot([y_iot.min(), y_iot.max()], [y_iot.min(), y_iot.max()],'k--', label="y=x (ideal)")
plt.xlabel("IoT (µg/m³)")
plt.ylabel("Referencia (µg/m³)")
plt.legend()
plt.title("Calibración lineal PM2.5")
plt.show()

""""Determine cual el alcance para realizar predicciones dentro de la tolerancia"
"""

order = np.argsort(pares_optimos)
centers = pares_optimos[order]
y_ref_t = y_ref[order]
y_iot_t = y_iot[order]

N = len(y_iot)
mid = N // 2

x_train, y_train = y_iot_t[:mid], y_ref_t[:mid]
x_test, y_test = y_iot_t[mid:], y_ref_t[mid:]

alpha_train = np.sum(x_train * y_train) / np.sum(x_train**2)
y_test_pred = alpha_train * x_test

promedio_test = np.sqrt(np.sum((y_test - y_test_pred)**2))
frac_test_within_abs = np.mean(np.abs(y_test - y_test_pred) <= tol_abs)

print("Alpha (train mitad):", alpha_train)
print("promedio en test mitad:", promedio_test)
print("Frac. dentro tol_abs en test:", frac_test_within_abs)

""""Determine entonces, el mínimo conjunto de datos para generar el modelo y cuál
sería su máximo alcance para una tolerancia dada"
"""

target_frac = 0.9
min_frac = None

for frac in np.linspace(0.1, 0.8, 15):
    n_train = max(2, int(frac * N))
    x_tr, y_tr = y_iot[:n_train], y_ref[:n_train]
    x_te, y_te = y_iot[n_train:], y_ref[n_train:]
    if len(x_te) == 0:
        continue
    alpha_tr = np.sum(x_tr * y_tr) / np.sum(x_tr**2)
    y_te_pred = alpha_tr * x_te
    frac_ok = np.mean(np.abs(y_te - y_te_pred) <= tol_abs)
    if frac_ok >= target_frac:
        min_frac = frac
        break

print("Fracción mínima entrenamiento (90% dentro tol_abs):", min_frac)